# B-Tree?
 B트리는 이진트리와 다르게 하나의 노드에 많은 수의 정보를 가지고 있을 수 있습니다. 최대 M개의 자식을 가질 수 있는 B트리를 M차 B트리라고 하며 다음과 같은 특징을 같습니다.

- 노드는 최대 M개 부터 M/2개 까지의 자식을 가질 수 있습니다. 
- 노드에는 최대 M−1개 부터 [M/2]−1개의 키가 포함될 수 있습니다.
- 노드의 키가 x개라면 자식의 수는 x+1개 입니다.
- 최소차수는 자식수의 하한값을 의미하며, 최소차수가 t라면 M=2t−1을 만족합니다. (최소차수 t가 2라면 3차 B트리이며, key의 하한은 1개입니다.)


### key 검색과정
- 루트노드에서 시작하여 하향식으로 검색을 수행합니다. 검색하고자 하는 key를 k라고 하였을 때 검색 과정입니다.

- 루트 노드에서 시작하여 key들을 순회하면서 검사합니다.
1-1 만일 k와 같은 key를 찾았다면 검색을 종료합니다.
1-2. 검색하는 값과 key들의 대소관계를 비교해봅니다. 어떠한 key들 사이에 k가 들어간다면 해당 key들 사이의 자식노드로로 내려갑니다.

해당 과정을 리프노드에 도달할 때까지 반복합니다. 만일 리프노드에도 k와 같은 key가 없다면 검색을 실패합니다.

### key 삽입과정
- key를 삽입하기 위해서는 1. 요소 삽입에 적절한 리프 노드를 검색하고, 2. 필요한 경우 노드를 분할해야 합니다. 리프노드 검색은 하향식이지만 노드 분할의 과정은 상향식으로 이루어진다고 볼 수 있습니다. 삽입하고자 하는 값을 k로 하였을 때 삽입 과정입니다.

- 트리가 비어있으면 루트 노드를 할당하고 k를 삽입합니다. 만일 루트노드가 가득 찼다면, 노드를 분할하고 리프노드가 생성됩니다.

- 이후부터는 삽압하기에 적절한 리프노드를 찾아 k를 삽입합니다. 삽입위치는 노드의 key값과 k값을 검색 연산과 동일한 방법으로 비교하면서 찾습니다.

- 이후 두가지 케이스로 나뉘게 됩니다.

### Case 1. 분할이 일어나지 않는 경우
리프노드가 가득차지 않았다면, 오름차순으로 k를 삽입합니다.

### Case 2. 분할이 일어나는 경우
- 만일 리프노드에 key노드가 가득 찬 경우, 노드를 분할해야 합니다.

- 오름차순으로 요소를 삽입합니다. 노드가 담을 수 있는 최대 key 개수를 초과하게 됩니다.

- 중앙값에서 분할을 수행합니다. 중앙값은 부모 노드로 병합하거나 새로 생성됩니다. 왼쪽 키들은 왼쪽 자식으로, 오른쪽 키들은 오른쪽 자식으로 분할됩니다.

- 부모 노드를 검사해서 또 다시 가득 찼다면, 다시 부모노드에서 위 과정을 반복합니다
